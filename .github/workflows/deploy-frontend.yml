name: Deploy Frontend Only to Linode

# This workflow deploys the frontend with SignalR-only configuration
# for optimal web performance. SignalR provides real-time WebSocket
# notifications for web users, while mobile apps use Firebase directly.

on:
  push:
    branches: [ main ]
    paths: [ 'yapplr-frontend/**' ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force frontend deployment'
        required: false
        default: 'false'

jobs:
  deploy-frontend:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Debug secrets
      run: |
        echo "LINODE_HOST is set: ${{ secrets.LINODE_HOST != '' }}"
        echo "LINODE_USER is set: ${{ secrets.LINODE_USER != '' }}"
        echo "SSH key is set: ${{ secrets.LINODE_SSH_KEY != '' }}"

    - name: Deploy Frontend to Linode
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.LINODE_HOST }}
        username: ${{ secrets.LINODE_USER }}
        key: ${{ secrets.LINODE_SSH_KEY }}
        port: 22
        timeout: 60s
        envs: FIREBASE_API_KEY,FIREBASE_AUTH_DOMAIN,FIREBASE_DATABASE_URL,FIREBASE_PROJECT_ID,FIREBASE_STORAGE_BUCKET,FIREBASE_MESSAGING_SENDER_ID,FIREBASE_APP_ID,FIREBASE_MEASUREMENT_ID,FIREBASE_VAPID_KEY
        script: |
          # Navigate to repository directory
          cd /opt/Yapplr
          git pull origin main

          # Configure SignalR-only for production frontend deployment
          echo "üîß Configuring SignalR-only for production frontend..."
          node configure-notifications.js signalr-only

          # Verify configuration was applied
          echo "‚úÖ Verifying SignalR-only configuration..."
          node configure-notifications.js status

          cd Yapplr.Api
          
          # Export Firebase variables for docker-compose build args
          export NEXT_PUBLIC_FIREBASE_API_KEY="$FIREBASE_API_KEY"
          export NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="$FIREBASE_AUTH_DOMAIN"
          export NEXT_PUBLIC_FIREBASE_DATABASE_URL="$FIREBASE_DATABASE_URL"
          export NEXT_PUBLIC_FIREBASE_PROJECT_ID="$FIREBASE_PROJECT_ID"
          export NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="$FIREBASE_STORAGE_BUCKET"
          export NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="$FIREBASE_MESSAGING_SENDER_ID"
          export NEXT_PUBLIC_FIREBASE_APP_ID="$FIREBASE_APP_ID"
          export NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID="$FIREBASE_MEASUREMENT_ID"
          export NEXT_PUBLIC_FIREBASE_VAPID_KEY="$FIREBASE_VAPID_KEY"

          # Export notification provider configuration (SignalR-only for production web)
          export NEXT_PUBLIC_ENABLE_FIREBASE=false
          export NEXT_PUBLIC_ENABLE_FIREBASE_WEB=false
          export NEXT_PUBLIC_ENABLE_SIGNALR=true
          export NEXT_PUBLIC_ENABLE_SIGNALR_MOBILE=false
          
          # Stop and rebuild only the frontend service
          echo "üõë Stopping frontend service..."
          docker-compose -f docker-compose.prod.yml stop yapplr-frontend

          echo "üóëÔ∏è Removing old frontend container and image..."
          docker-compose -f docker-compose.prod.yml rm -f yapplr-frontend
          docker image rm yapplrapi_yapplr-frontend:latest || true

          echo "üî® Building new frontend image..."
          docker-compose -f docker-compose.prod.yml build yapplr-frontend

          echo "üöÄ Starting frontend service..."
          docker-compose -f docker-compose.prod.yml up -d yapplr-frontend

          # Ensure nginx is running (it may already be running from API deployment)
          echo "üåê Ensuring nginx is running..."
          docker-compose -f docker-compose.prod.yml up -d nginx
          
          # Wait for frontend to be ready
          echo "‚è≥ Waiting for frontend to be ready..."
          sleep 20
          

          
          echo "‚úÖ Frontend deployment completed!"
      env:
        FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
        FIREBASE_AUTH_DOMAIN: ${{ secrets.FIREBASE_AUTH_DOMAIN }}
        FIREBASE_DATABASE_URL: ${{ secrets.FIREBASE_DATABASE_URL }}
        FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_STORAGE_BUCKET: ${{ secrets.FIREBASE_STORAGE_BUCKET }}
        FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}
        FIREBASE_APP_ID: ${{ secrets.FIREBASE_APP_ID }}
        FIREBASE_MEASUREMENT_ID: ${{ secrets.FIREBASE_MEASUREMENT_ID }}
        FIREBASE_VAPID_KEY: ${{ secrets.FIREBASE_VAPID_KEY }}
          
    - name: Frontend Health Check
      run: |
        sleep 10
        # Check if the main site is accessible (frontend is served through nginx)
        curl -f https://yapplr.com || echo "Frontend health check failed, but this might be expected if domain isn't configured"
